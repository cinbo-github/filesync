目标端，传回目标文件的情况文件。
格式。

服务端和客户端的交互过程。 这里先忽略权限的问题。
服务程序有对同步目录的权限，ip 限制，发起用户限制。 新建连接都是通过ssl/tls。

文件创建时间，文件修改时间。 文件大小。

1对1同步。
单向网络即可 进行同步。不需要双向网络通。

同步规则，同步规则支持条件判断。
支持定时执行文件操作。1.检查是否存在某文件，2，删除，3，改名，4、同步，5，发送到指定服务器。

可以简单的执行逻辑，下一个逻辑按照上一个逻辑执行。

单点认证，token，一定要有ip过滤。有ip白名单黑名单。

用户 map这个功能去掉。


任务。任务的类型：
    定时任务，有定点触发的任务
    间隔任务，每隔一定时间的任务，
    实时任务，一旦有什么动作那么触发什么操作。触发的操作，是个接口方法。

可以本地配置，也可以远程配置。本地是一个sqlite数据库。



单次同步流程：
1、如果从client发起同步请求，
    1、dest->src,把当前需要同步的信息,发送到源端。（把本地的同步内容的信息，目录，文件的创建时间，最后改动时间，最后访问时间，每个文件的同步方式）
    2、src->dest，根据客户端的信息，判断本地的内容。然后把同步清单内容，发送给客户端。同时，发送一个token(token的过期，一个是时间，一个是客户端发送结束请求)给客户端。
     2.1 先做目录改动请求(根据需求新增，删除（真的是删除)，以及改名)。

        1、dest->src,发送同步请求,请求。这个时候的同步速度由客户端和服务端协商。哪个地用哪个。
        2、src->dest，按照同步请求内容，把内容发送到目标端进行进行合并。
        3、dest, 修改文件的信息（时间）
        4、src,保存同步信息，src目录下,在目录下有一个.rsync 目录,levelDB模式，文件名，目标ip+目标hostname+文件+。
        都通过sqlite3，目录信息和
2、如果从目标端发起了同步请求，

单次同步时，读取配置文件（主要是每个文件的同步方式，include或者是exclude清单）
源端把文件创建时间，文件修改时间，文件大小，发送到目标端。目标端根据这些判断哪些文件需要同步，然后把需要同步的内容，收集好检验和以及同步方式
发送到源端。源端根据这些文件清单，执行rsync检查，生成增量数据。把增量数据发送到目标端进行同步。
源端需要记录最后一次同步的数据，同步的文件清单，每个文件的最后修改时间.  下一次同步的时候，如果发现时间没变，就不需要改动了。






准实时同步：（主要是每个文件的同步方式，include或者是exclude清单）
第一次：
源端把文件创建时间，文件修改时间，文件大小，发送到目标端。目标端根据这些判断哪些文件需要同步，然后把需要同步的内容，以及同步方式发送给源端。
源端根据要求，同步所有内容。
记录同步的内容， 文件大小，创建时间，修改时间，DELETE时间，同步方式。

以后：
每隔固定时间同步，配置的秒同步一次。 同步时，看改动记录，里面有modify的就进行同步，或者delete和create

delete和create要重视。
如果是改名字操作，java只能抓到delete和create。只能通过目录和文件的创建时间去判断，这个目录是否是改动的还是新建的。
所以，同步时，需要事先扫描所有目录，并把目录内的所有文件和目录的创建时间记录下来(微秒)。供后来改动时判断，是改了文件名还是真的新建了文件夹或者是

连接是通过SSL双向认证，
IP地址过滤，用户过滤。







